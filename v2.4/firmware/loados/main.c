#include "loados.h"

// main.c

// BOGUS versions of these.
gbyte gIrqSaveAndDisable() {return 0;}
void gIrqRestore(gbyte x) {}

// Hardware Reference -- Thanks, Tim!
//     https://tlindner.macmess.org/?page_id=767

// pia_reset_sequence table traced from coco3 startup.
struct pia_reset_sequence {
    gword addr;
    gbyte value;
} pia_reset_sequence[] = {
    { 0xff21, 0x00 },  // choose data direction
    { 0xff23, 0x00 },  // choose data direction
    { 0xff20, 0xfe },  // bit 0 input; rest are outputs.
    { 0xff22, 0xfa },  // bit 1 and bits 3-7 are outputs.
    { 0xff21, 0x34 },
    { 0xff23, 0x34 },
    { 0xff22, 0x00 },  // output all 0s on Pia1 PortB
    { 0xff20, 0x02 },
    { 0xff01, 0x00 },  // choose data direction
    { 0xff03, 0x00 },  // choose data direction
    { 0xff00, 0x00 },  // inputs
    { 0xff02, 0xff },  // outputs
    { 0xff01, 0x34 },
    { 0xff03, 0x34 },
    { 0 }
};


// gime_reset_sequence table traced from coco3 startup.
struct gime_reset_sequence {
    gword addr;
    gbyte value;
} gime_reset_sequence[] = {
// Generated by copico-bonobo/v2.4/firmware/c$ py gime_init_gen.py 
  { 0xff90, 0xcc },
  { 0xff91, 0x00 },
  { 0xff92, 0x00 },
  { 0xff93, 0x00 },
  { 0xff94, 0xff },
  { 0xff95, 0xff },
  { 0xff96, 0x00 },
  { 0xff97, 0x00 },
  { 0xff98, 0x00 },
  { 0xff99, 0x00 },
  { 0xff9a, 0x00 },
  { 0xff9b, 0x00 },
  { 0xff9c, 0x0f },
  { 0xff9d, 0xe0 },
  { 0xff9e, 0x00 },
  { 0xff9f, 0x00 },
  { 0xffa0, 0x38 },
  { 0xffa1, 0x39 },
  { 0xffa2, 0x3a },
  { 0xffa3, 0x3b },
  { 0xffa4, 0x3c },
  { 0xffa5, 0x3d },
  { 0xffa6, 0x3e },
  { 0xffa7, 0x3f },
  { 0xffa8, 0x38 },
  { 0xffa9, 0x30 },
  { 0xffaa, 0x31 },
  { 0xffab, 0x32 },
  { 0xffac, 0x33 },
  { 0xffad, 0x3d },
  { 0xffae, 0x35 },
  { 0xffaf, 0x3f },
  { 0xffb0, 0x12 },
  { 0xffb1, 0x24 },
  { 0xffb2, 0x0b },
  { 0xffb3, 0x07 },
  { 0xffb4, 0x3f },
  { 0xffb5, 0x1f },
  { 0xffb6, 0x09 },
  { 0xffb7, 0x26 },
  { 0xffb8, 0x00 },
  { 0xffb9, 0x12 },
  { 0xffba, 0x00 },
  { 0xffbb, 0x3f },
  { 0xffbc, 0x00 },
  { 0xffbd, 0x12 },
  { 0xffbe, 0x00 },
  { 0xffbf, 0x26 },
  { 0 }
};

void Delay(gword n) {
    for (gword i = 0; i < n; i++) {
        asm volatile(" mul \n mul \n mul \n mul \n mul" : : : "d");
    }
}

void ColdPrint(const char* s) {
    PutStr("___ ");
    PutStr(s);  
    PutChar('\n');

    // Assuming PIA0 is already set up for keyboard scanning:
    gPoke1(KEYBOARD_PROBE, ~(1<<4)); // Probe for Down Arrow
    gbyte sense = ((1<<3) & ~gPeek1(KEYBOARD_SENSE));
    if (sense) {
        Delay(10000);
    } else {
        Delay(10);
    }
}

void entry_wrapper() {
    asm volatile("\n"
        "  .globl entry \n"
        "entry:         \n"
        "  orcc #$50    \n"  // No IRQs, FIRQs, for now.
        "  lds #$4000   \n"  // Reset the stack
        "  jmp _main    \n"
        );
}

void SplashRestore(int x, int y) {
    if (x < 0) return;
    if (y < 0) return;
    if (x >= 32) return;
    if (y >= 16) return;
    gPoke1(Cons + 32*y + x, gPeek1(0x200 + 32*y + x));
}

void SplashSet(int x, int y) {
    if (x < 0) return;
    if (y < 0) return;
    if (x >= 32) return;
    if (y >= 16) return;
    gPoke1(Cons + 32*y + x, 0xAF);
}

void Splash() {
    memcpy_words(0x0200, 0x0400, 256);
    memset_words(0x0400, 0x1C1C, 256);  // $1C <- $5C <- '\\'

        for (int i = 0; i < 16; i++) {
            for (int x = 16 - i; x < 16 + i; x++) {
                int y1 = 8 - (i>>1);
                int y2 = 8 + (i>>1);
                SplashSet(x, y1);
                SplashSet(x, y2);
            }
            for (int y = 8 - (i>>1); y <= 8 + (i>>1); y++) {
                int x1 = 16 - i;
                int x2 = 16 + i;
                SplashSet(x1, y);
                SplashSet(x2, y);
            }
            Delay(200);

            for (int x = 16 - i; x < 16 + i; x++) {
                int y1 = 8 - (i>>1);
                int y2 = 8 + (i>>1);
                SplashRestore(x, y1);
                SplashRestore(x, y2);
            }
            for (int y = 8 - (i>>1); y <= 8 + (i>>1); y++) {
                int x1 = 16 - i;
                int x2 = 16 + i;
                SplashRestore(x1, y);
                SplashRestore(x2, y);
            }
        }
}

void setup(void) {
    memset_words(0x0000, 0, 0x80); // Direct Page .bss

    for (struct pia_reset_sequence *p = pia_reset_sequence; p->addr; p++) {
        gPoke1(p->addr, p->value);
    }
    gPoke1(0xFF90, 0x88);
    gPoke1(0xFF91, 0x00);

    // Sam Pre-Init to TEXT AT 0x0400 for Cold Boot
    for (gword p = 0xFFC0; p < 0xFFD4; p+=2) {
        gbyte yes = (p == 0xFFC8);
        gPoke1(p+yes, 0);
    }

    Console_Init();
    ColdPrint("^^^^^^^^^^^^^^^^");
    ColdPrint("^^^          ^^^");
    ColdPrint("^^^  COPICO  ^^^");
    ColdPrint("^^^  BONOBO  ^^^");
    ColdPrint("^^^  LOADOS  ^^^");
    ColdPrint("^^^          ^^^");
    ColdPrint("^^^^^^^^^^^^^^^^");

    Splash();

    if (0) { // D5?
        gPoke1(0xFFD5, 0);
        ColdPrint("D5");
    } else {
        gPoke1(0xFFD4, 0);
        ColdPrint("D4");
    }

    gPoke1(0xFFD6, 0);  // slow CPU speed.
    ColdPrint("D6");
    gPoke1(0xFFD8, 0);
    ColdPrint("D8");

    // DA and DC are for memory size.
    gPoke1(0xFFDB, 0);
    ColdPrint("DB");
    gPoke1(0xFFDC, 0);
    ColdPrint("DC");

    gPoke1(0xFFDF, 0);
    ColdPrint("DF");  // all RAM

    for (struct gime_reset_sequence *p = gime_reset_sequence; p->addr; p++) {
        gPoke1(p->addr, p->value);
    }
    ColdPrint("GIME");
    // Coco3 in Compatibility Mode.
    gPoke1(0xFF90, 0x88);
    gPoke1(0xFF91, 0x00);
    ColdPrint("COMPAT");

    Network_Init();
}

gbool volatile True;

void gFatal(const char *s, gword arg) {
    ColdPrint(s);

    True = 1;
    while (True) {
        gPoke2(Cons, gPeek2(Cons));
    }
}

int main() {
    gPin(entry_wrapper);

    setup();
    RequestLoadOs();

    True = 1;
    while (True) {
        Loop();
    }

    // NOT REACHED
    gFatal("MAIN", 0);
}
